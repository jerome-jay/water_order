---
AWSTemplateFormatVersion: "2010-09-09"
Description : "Creates EC2 running tomcat"

Parameters:
  PrivateSubnetsParam:
    Description: "List of private subnets, which is where we will build our servers"
    Type: List<AWS::EC2::Subnet::Id>
  PublicSubnetsParam:
    Description: "List of public subnets, which is where we will build our ALB"
    Type: List<AWS::EC2::Subnet::Id>
  VpcId:
    Type: "AWS::EC2::VPC::Id"
  CidrIp:
    Description: 'IP range of our VPC - to allow health check'
    Type: 'String'
  SecurityGroupIds:
    Description: "The IDs of security groups that are attached to our EC2 instances"
    Type: "List<String>"
  ImageId:
    Type: "String"
    Description: "AMI ID to use"
  KeyPairName:
    Type: "String"
    Description: "SSH key attached"
  ApplicationName:
    Type: "String"
    Description: "Name of the application"
  S3BucketName:
    Type: "String"
    Description: "Location of the artefact"
  Artefact:
    Type: "String"
    Description: "Path and name of the artefact"
  HostedZoneName:
    Description: "Name of the hosted zone"
    Type: "String"
  SSLCertificateId:
    Description: "Arn of the certificate for the internal ELB"
    Type: 'String'


  InstanceType:
    Description: "Type of autoscaling instance"
    Type: "String"
  MinInstanceCount:
    Description: "The minimum number of instances for the ASG"
    Type: "Number"
    Default: 1
  MaxInstanceCount:
    Description: "The maximum number of instances for the ASG"
    Type: "Number"
    Default: 1

Resources:
  Ec2SecurityGroup:
    Properties:
      GroupDescription: "Allow load balancer traffic to instances"
      SecurityGroupIngress:
        - FromPort: 80
          IpProtocol: "tcp"
          SourceSecurityGroupId: !Ref "LoadBalancerSecurityGroup"
          ToPort: 80
      VpcId: !Ref "VpcId"
    Type: "AWS::EC2::SecurityGroup"
  LoadBalancerSecurityGroup:
    Properties:
      GroupDescription: "Allow inbound traffic from everywhere"
      SecurityGroupIngress:
      - CidrIp: "0.0.0.0/0"
        FromPort: 443
        IpProtocol: "tcp"
        ToPort: 443
      VpcId: !Ref "VpcId"
    Type: "AWS::EC2::SecurityGroup"
  TargetGroup:
    Type: 'AWS::ElasticLoadBalancingV2::TargetGroup'
    Properties:
      HealthCheckIntervalSeconds: 10
      HealthCheckPath: "/health"
      HealthCheckPort: 443
      HealthCheckProtocol: "HTTPS"
      HealthyThresholdCount: 2
      UnhealthyThresholdCount: 2
      Port: 443
      Protocol: TCP
      VpcId: !Ref "VpcId"
  ApplicationLoadBalancer:
    Type: 'AWS::ElasticLoadBalancingV2::LoadBalancer'
    Properties:
      SecurityGroups: !Split [ ",", !Ref "LoadBalancerSecurityGroup" ]
      LoadBalancerAttributes:
        - Key: deletion_protection.enabled
          Value: 'false'
      Scheme: "Internet-facing"
      Subnets: !Ref "PublicSubnetsParam"
      Type: network
  LBListener:
    Type: 'AWS::ElasticLoadBalancingV2::Listener'
    Properties:
      DefaultActions:
        - TargetGroupArn: !Ref "TargetGroup"
          Type: forward
      LoadBalancerArn: !Ref "ApplicationLoadBalancer"
      Port: 443
      Protocol: TCP

  InstanceProfile:
    Properties:
      Path: "/"
      Roles:
        - !Ref "InstanceRole"
    Type: "AWS::IAM::InstanceProfile"
  InstanceRole:
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Action:
              - sts:AssumeRole
            Effect: "Allow"
            Principal:
              Service:
                - ec2.amazonaws.com
        Version: "2012-10-17"
      Path: "/"
    Type: "AWS::IAM::Role"

  Policy:
    Properties:
      PolicyDocument:
        Statement:
          - Action:
              - cloudformation:DescribeStacks
              - ec2:Describe*
            Effect: "Allow"
            Resource: "*"
          - Action:
              - s3:ListBucket
            Effect: "Allow"
            Resource: !Sub "arn:aws:s3:::${S3BucketName}"
          - Action:
              - s3:GetObject
            Effect: "Allow"
            Resource: !Sub "arn:aws:s3:::${S3BucketName}/*"
        Version: "2012-10-17"
      PolicyName: !Sub "${ApplicationName}Policy"
      Roles:
        - !Ref "InstanceRole"
    Type: "AWS::IAM::Policy"

  Dns:
    Properties:
      HostedZoneName: !Sub "${HostedZoneName}."
      RecordSets:
        - Name: !Sub "${ApplicationName}.${HostedZoneName}."
          Type: "A"
          AliasTarget:
            HostedZoneId: !GetAtt [ "ApplicationLoadBalancer", "CanonicalHostedZoneID" ]
            DNSName: !GetAtt [ "ApplicationLoadBalancer", "DNSName" ]
    Type: "AWS::Route53::RecordSetGroup"

  LaunchTemplate:
    Type: 'AWS::EC2::LaunchTemplate'
    Properties:
      LaunchTemplateData:
        BlockDeviceMappings:
          - DeviceName: "/dev/sda1"
            Ebs:
              VolumeSize: !Ref "VolumeSize"
        CreditSpecification:
          CpuCredits: !If [UseCredits, "standard", !Ref "AWS::NoValue"]
        ImageId: !Ref "ImageId"
        InstanceType: !Ref "InstanceType"
        KeyName: !Ref "KeyPairName"
        IamInstanceProfile:
          Name: !Ref "InstanceProfile"
        InstanceInitiatedShutdownBehavior: terminate
        Monitoring:
          Enabled: true
        NetworkInterfaces:
          - AssociatePublicIpAddress: false
            DeleteOnTermination: true
            DeviceIndex: 0
            Groups: !Split [ ",", !Ref "Ec2SecurityGroup" ]
        UserData:
          'Fn::Base64':
            !Sub |
              #!/bin/bash -x
              exec > >(tee /var/log/user-data.log | logger -t user-data) 2>&1
              (
                date
                set -e

                date
                # download our package
                cd /tmp; mkdir APIGW; cd APIGW
                aws s3 cp s3://${S3BucketName}/builds/${BRANCHNAME}/${Artefact} .
                tar -zxvf ${Artefact}

                # Install tomcat

                date
                signal=1
                health=$(wget -q -O - --retry-connrefused --no-check-certificate -T 120 https://localhost/health )
                exitcode=$?
                if [ "$exitcode" -eq 0 ]
                then
                  signal=0
                fi

                date
                # setting set +e: script will not stop if something fails, as we don't care from here onwards, AND the cfn-signal exits with a non-OK return when the stack is in UPDATE_COMPLETE status
                set +e

                cfn-signal -e $signal --stack ${AWS::StackName} --resource AutoScalingGroup --region ${AWS::Region}
              )
    DependsOn:
      - InstanceRole
  AutoScalingGroup:
    Type: 'AWS::AutoScaling::AutoScalingGroup'
    Properties:
      MaxSize: !Ref "MaxInstanceCount"
      MinSize: !Ref "MinInstanceCount"
      TargetGroupARNs: !Split [',', !Ref "TargetGroup"]
      LoadBalancerNames: !Split [',', !Ref "ELB"]
      LaunchTemplate:
        LaunchTemplateId: !Ref "LaunchTemplate"
        Version: !GetAtt "LaunchTemplate.LatestVersionNumber"
      VPCZoneIdentifier: !Ref "PrivateSubnetsParam"
      TerminationPolicies:
        - "OldestInstance"
      MetricsCollection:
        - Granularity: "1Minute"
      HealthCheckGracePeriod: 500
      HealthCheckType: "ELB"
    CreationPolicy:
      ResourceSignal:
        Count: !Ref "MinInstanceCount"
        Timeout: "PT10M"
    UpdatePolicy:
      AutoScalingRollingUpdate:
        MinInstancesInService: !Ref "MinInstanceCount"
        PauseTime: "PT10M"
        WaitOnResourceSignals: true
        SuspendProcesses:
          - "ScheduledActions"
          - "HealthCheck"
          - "ReplaceUnhealthy"
          - "AZRebalance"
          - "AlarmNotification"
